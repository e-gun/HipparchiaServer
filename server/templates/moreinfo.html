
<div id="moreinfotabs">
<ul>
    <li><a href="#Interface"><span>Interface</span></a></li>
    <li><a href="#Browsing"><span>Browsing</span></a></li>
    <li><a href="#MakingSearchLists"><span>Searching: Building search lists</span></a></li>
    <li><a href="#RegexSearching"><span>Searching: REGEX</span></a></li>
    <li><a href="#HitsAndMisses"><span>Searching: Hits and Misses</span></a></li>
    <li><a href="#SpeedSearching"><span>Searching: Speed</span></a></li>
    <li><a href="#Oddities"><span>Peculiarities and Gotchas</span></a></li>
    <li><a href="#Openness"><span>Openness</span></a></li>
</ul>

    <div id="Interface">
    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Help">
        <span class="ui-icon ui-icon-help"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Open/Close info panel</span></p>
        <p class="explanation">If you are reading this, then you have already harnessed half of this button's power.</p>

    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Reset session">
        <span class="ui-icon ui-icon-close"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Clear session</span></p>
        <p class="explanation">This will reset all session variables. Strong stuff. Search criteria, etc. will all be cleared.
        All values will be restored to their defaults. Many of these defaults can be set in <code>config.py</code>.</p>

    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Include this category and/or genre">
        <span class="ui-icon ui-icon-plus"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Add to search list.</span></p>
        <p class="explanation">Whatever you see in the selection boxes will be added to the 'searching within' list. See the tab
        <span class="italic">Searching: Building search lists</span> for details.</p>

    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Exclude this category and/or genre">
        <span class="ui-icon ui-icon-minus"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Add to exclusion list.</span></p>
        <p class="explanation">Whatever you see in the selection boxes will be added to the list of things that will not be searched.
        See the tab <span class="italic">Searching: Building search lists</span> for details.</p>

    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="More search choices">
        <span class="ui-icon ui-icon-arrowreturnthick-1-s"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Show additional corpora</span></p>
        <p class="explanation">Make further selection criteria avalable.</p>

    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="More search choices">
        <span class="ui-icon ui-icon-arrowreturnthick-1-n"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Hide additional corpora</span></p>
        <p class="explanation">Make further selection criteria unavalable.</p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Lexical tools">
        <span class="ui-icon ui-icon-wrench"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Open/Close lexical tools panel</span></p>
        <p class="explanation">Look up words in the dictionary. Parse words.</p>

    <p class="interfacetips"><button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Search">
        <span class="ui-button-icon ui-icon ui-icon-search"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Perform a search</span></p>
        <p class="explanation">Will search based on the information in the neighboring boxes.</p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Configuration options">
        <span class="ui-icon ui-icon-gear"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Open/Close settings panel</span></p>
        <p class="explanation">Change your preferences here.</p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Browse this location">
        <span class="ui-icon ui-icon-note"></span><span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Browse this location</span></p>
        <p class="explanation">
        Open a text browser window to explore the work and location that is presently showing in the selection
            fields. Incomplete selections will send you to the first valid possibility:
            the first line of the first work of an author;
            the first line of a selected work; the first chapter of that book of that work; ...
        </p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Generate a simple text of this selection">
        <span class="ui-icon ui-icon-bookmark"></span><span class="ui-button-icon-space"> </span>&nbsp;</button>
         <span class="label">Generate a simple text of this selection</span></p>
        <p class="explanation">
            Generate a simple text of the work and location that is presently showing in the selection fields.
            Incomplete selections will give you to the first valid possibility:
            the whole of the first work of an author; the whole of the first book of a selected work; ...
            This is less useful for works like plays that are broken up only by lines: either the whole play will be shown
            or just an individual line.
    </p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Build a concordance for this work">
        <span class="ui-icon ui-icon-calculator"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>

        <span class="label">Build a concordance</span></p>
        <p class="explanation">A concordance for the current selection will be built in a new window. The time required increases dramatically as works get longer.
        And it will take a very long time indeed to compile a concordance for something like Cassius Dio's <span class="italic">Historiae Romanae</span>.
            Then again, how long would it take to do this by hand? As with the browser and text maker, the concordance
        maker is sensitive to the details of your selections: it will make a concordance of a whole author; a whole work; or
        any arbitrary subdivision of a work all the way down (somewhat comically) to an individual line. </p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Show/Hide local info about the works of this author">
        <span class="ui-icon ui-icon-person"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Show/Hide local info about the works of this author</span></p>
        <p class="explanation">Take a peek at the database info attached to this author: genre classification of the author and the individual works;
            date assigned; works of the author; editions from which the works are taken.</p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Show/Hide list of available categories">
        <span class="ui-icon ui-icon-clipboard"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Show/Hide list of available categories</span></p>
        <p class="explanation">View the list of categories into which authors and works have been sorted.
        This option is only visible inside of 'further selection criteria' (<span class="ui-icon ui-icon-arrowreturnthick-1-s"></span>)</p>
    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Complicate the search">
        <span class="ui-button-icon ui-icon ui-icon-arrow-1-e"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Open complex searching options</span></p>
        <p class="explanation">Search for X near Y and within N words/lines</p>

      <p class="interfacetips">
        <span class="ui-icon ui-icon-disk"></span>
            <span class="label">Pick a save slot into which to save your current session</span></p>
        <p class="explanation">Five little buttons will appear (➊, ➋, ...). Click on one of them to store your current settings.
        Active corpora, search lists, sorting preferences, etc. will all be stored. Query terms and actual search results
            will not be stored.
        </p>

          <p class="interfacetips">
        <span class="ui-icon ui-icon-folder-open"></span>
            <span class="label">Pick a save slot from which to load stored session</span></p>
        <p class="explanation">Five little buttons will appear (➀, ➁, ...). Click on one of them to restore saved settings.
        Active corpora, search lists, sorting preferences, etc. will all be fetched. Query terms and actual search results
            will not be fetched.</p>
</div>

<div id="Browsing">
    <p class="interfacetips">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Browse backwards (click or press the &#8592; key)">
        <span class="ui-icon ui-icon-arrowthick-1-w">&nbsp;</span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>&nbsp;&nbsp;&nbsp;&nbsp;
        <span class="label">Browse backwards (click or press the &#8592; key)</span></p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Close the browser">
        <span class="ui-icon ui-icon-close">&nbsp;</span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>&nbsp;&nbsp;&nbsp;&nbsp;
        <span class="label">Close the browser</span></p>

    <p class="interfacetips">
        <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Browse forwards (click or press the &#8594; key)">
        <span class="ui-icon ui-icon-arrowthick-1-e">&nbsp;</span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>&nbsp;&nbsp;&nbsp;&nbsp;
        <span class="label">Browse forwards (click or press the &#8594; key)</span></p></p>
    </div>

<div id="MakingSearchLists">
    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Include this category and/or genre">
        <span class="ui-icon ui-icon-plus"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Add an item to the search list</span><br />
        <p class="explanation">Use the information in the box or boxes to the left of this button to append an item to the list of things one is searching for.
        These can be whole authors, whole works, parts of works, whole classes of authors, and whole classes of work.</p>

        <p class="explanation">For example: adding the author <span class="emph">Plato</span> and the class <span class="emph">Tragici</span>, you could compare Plato and tragedians.
        Similarly the author <span class="emph">Plato</span> and the work genre <span class="emph">Satyr.</span> would let you compare Plato and satyr plays.
        Likewise the work <span class="emph">Thucydides, <span class="italic">Historiae</span></span> could be combined with <span class="emph">Herodotus, <span class="italic">Historiae</span></span>.
        This could be further refined down to <span class="emph">Thucydides, <span class="italic">Historiae</span> Book 1</span> and <span class="emph">Herodotus, <span class="italic">Historiae</span> Book 1</span>.
        In fact absurd levels of specificity can be chosen: <span class="emph">Thucydides , <span class="italic">Historiae</span> Book 1, chapter 114, section 2, line 2</span> is a perfectly valid selection.
        </p>

    <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Exclude this category and/or genre">
        <span class="ui-icon ui-icon-minus"></span>
        <span class="ui-button-icon-space"> </span>&nbsp;</button>
        <span class="label">Add an item to the exclusion list</span><br />
        <p class="explanation">Use the information in the box or boxes to the left of this button to append an item to the list of things one is not going to search for.
        These can be whole authors, whole works, parts of works, whole classes of authors, and whole classes of work.</p>
        <p class="explanation">For example: adding the author <span class="emph">Plato</span> and the class <span class="emph">Tragici</span> to the exclusion list, you could search for the use of a term outside of Plato and Tragedy.
        Mixing inclusions and exclusions can produce interesting possibilities: the author <span class="emph">Plutarch</span> as a selection and the work genre <span class="emph">Biogr.</span> as an exclusion yields all of Plutarch but for the <span class="italic">Lives</span>.
        Similarly adding <span class="emph">Homer</span> and <span class="emph">Epici</span> and excluding <span class="emph"><span class="italic">Ilias</span></span> and then setting the time restriction to 850BCE to 500 CE will give you non-Iliadic early epic. Consider tossing in some <span class="emph">Hymn.</span> for good measure...
        It is also possible to search something like <span class="emph">Herodotus, <span class="italic">Histories</span></span> less books 1 and 2 by adding the former to the selection list and the latter to the exclusion list.
        But excluding a subsection within a section is not supported: Book 1 less section 1 has not been implemented and probably never will be.
        </p>

    <p><span class="ui-button-icon ui-icon ui-icon-trash" title="Drag here to remove item from list">&nbsp;</span>
        <span class="label">Remove item from list</span></p>
        <p class="explanation"><span class="emph">Click and drag</span> items from the include/exclude list here. Release the mouse button. Boom: the item is gone.
        </p>


    <p><span class="ui-button-icon ui-icon ui-icon-info" title="Show/hide details of the current search list">&nbsp;</span>
        <span class="label">Check the contents of your current search list</span></p>
        <p class="explanation">If you searched now for <span class="emph">Tragici</span> what text would you in fact search? Click on the <span class="emph">info</span> button to find out.
        This should give you a list of <span class="emph">works</span> that reflect all of the inclusions and exclusions currently in effect.
        </p>

        <fieldset><legend>Earliest date to search</legend><input type="text" value="-850" width="25px;"></fieldset>
        <fieldset><legend>Latest date to search</legend><input  type="text" value="1500" width="25px;"></fieldset>
        <p class="explanation">Choose a chronological span within which to limit the search. Note that the dates assigned to authors are very approximate
        and derived from original data that can look like <code>i-iii A.D.</code>. Such an author would be assigned to <code>200 CE</code>. <code>iv B.C</code> becomes <code>350 BCE</code>. A variety of quirks in the
        original data has become a variety of quirks here. Similarly many authors have no date at all and some works
            have a variety of dates because they are composite. You enable searches for <code>Varia</code> and/or <code>Incerta</code>
            if you have a time restriction on your search. A search with no restriction will include such texts automatically. <span class="emph">Otherwise they are excluded</span>.
            Check your search lists (<span class="ui-button-icon ui-icon ui-icon-info" title="Show/hide details of the current search list">&nbsp;</span>)
        to make sure you are getting what you want. Searching within a date range that is smaller than one century is likely to yield some measure of disappointment.
        Users are quite free to update authors with their own superior dates, but that requires learning SQL. Please consider sharing with others any/all improvements that you make to the original data.<br />
        <br />
        Note that there is a conflict between time as an exclusion principle and the selection list. Which should take priority? This question has been resolved as follows:
            <span class="emph">specific selections take priority over more general chronological exclusions</span>. And so:
        <ul class="forexample">
            <li>zero selections + no date restriction (-850 to 1500): search <span class="emph">all active corpora</span></li>
            <li>zero selections + a date restriction: search for everybody within that date range; e.g., <span class="emph">5th century BCE Greek authors</span> (if this is your only active corpus)</li>
            <li>zero selections + a class or classes + a date restriction: search for all members of the class(es) within that date range; e.g. <span class="emph">epic before 1 C.E.</span></li>
            <li>an author/work/passage + a class or classes + a date restriction: search for the specific item(s) and search for all members of the class(es) within that date range;
                e.g. <span class="emph">Plutarch's <span class="italic">Solon</span></span> and <span class="emph">4th century BCE Greek orators</span></li>
        </ul>
        </p>
</div>

<div id="RegexSearching">

    Regular expressions allow you to search for patterns and to use wildcards. Regex is a dark art unto itself. Consult the <a href="https://www.postgresql.org/docs/9.6/static/functions-matching.html">manual directly</a>.
    <br />
    The more salient things to know/use:
    <ul class="forexample">
        <li><code>[abc]</code> brackets a set of acceptable characters to look for in the next position: a, or b, or c.
            <code>lauda[st]</code> will find <span class="lat">laudas</span> or <span class="lat">laudat</span> but not <span class="lat">laudare</span>. </li>
        <li><code>[^abc]</code> brackets a set of characters to exclude in the next position: not a, nor b, nor c.
            <code>lauda[^t]</code> is a search that refuses to find <span class="lat">laudat</span>, but it will find <span class="lat">laudant</span>,
            <span class="lat">laudandum</span>, and <span class="lat">laudasti</span>.</li>
        <li><code>(a|b|abc)</code> brackets a set of strings to look for: a, or b, or abc. <code>laud(o|as|at)</code>
            is a search for the present singular indicative forms of <span class="lat">laudare</span>. It will also find
            <span class="lat">conlaudat</span>. Note how you could use <code>co(n|l)laud</code> to make sure you got alternate
            spellings of <span class="lat">conlaudare</span>.</li>
        <li><code>.</code> any character: <code>laud.nt</code> will find <span class="lat">laudant</span>, <span class="lat">laudent</span>,
            and, theoretically, <span class="lat">laudZnt</span></li>
        <li><code>\s</code> whitespace: <code>\ssed\setiam\s</code> is a search for <code>' sed etiam '</code>.
            Please use the 'within 1 word' function instead of <code>\s</code> unless you know why you are not doing so.
    </ul>
    Here are some examples that give you an idea of the sort of things that are possible. But major caveats follow.
    <ul class="forexample">
        <li><code>\s\w\w\s\w\w\s\w\w\s\w\w\s</code> will find all runs of four words of two letters each.</li>
        <li><code>t.t.t.t.t.</code> will find places where you have 't + anything' five times in a row.
            Your results will be <span class="lat">heres ei extitit Titius</span>; and <span class="lat">nec diu restitit: tota...</span>
            Note that the whitespace between <span class="lat">extitit</span> and <span class="lat">Titius</span> qualified
            as 'anything' in the first match. But you might have composed the search with something else in mind.</li>
        <li><code>\s..$</code> could find all verses of Homer that end with a two letter word.<span class="emph">[*]</span></li>
        <li><code>^[^αειουηω][^\s]\s</code> could find all verses of Homer that begin with a two letter word that does not itself start with
            a vowel.<span class="emph">[*]</span>
            Matches include: βῆ, μή, ϲῷ, τῇ, and τῷ. Unfortunately matches also include —※. That is, the editorial marks count as part
            of the start of the line. 
            The same search is a problem in dramatists for a similar reason. Punctuation is stripped out of
            the searchable columns and that means that speakers like 'ΚΗ.' and 'ΔΙ.' become 'κη' and 'δι'. They will match the pattern. 
            And, obviously, speaker attribution in dramas will be able to produce all sorts of possible matches with other searches too. 
        </li>
        <li><code>[aeiou]m[aeiou]m[aeiou]m</code> will find words that have 'vowel + m + vowel + m + vowel + m'
            (i.e., <span class="lat">amomum, cardamomum, cinnamomum, pantomimum</span>) </li>
        <li><code>(i.o.a.){2,}</code> will find 'i + anything + o + anything + a + anything' where this sequence can be found
            two or more times in a row. Three phrases that have this structure are <span class="lat">Punico acido arido</span>,
            <span class="lat">sollicito animo an</span> and <span class="lat">aequissimo animo ad</span>
        </li>
        <li><code>\sζ[^\s]*?ζ[^\s]*?ουσ</code> will find all words that start with a ζ and then have another ζ internally and
            then have ουσ still later on. ζυμίζουϲα, ζιζανιώδουϲ, and Ζήζουϲ are all matches.<span class="emph">[*]</span>
        </li>
        <li><span class="emph">[warning: see below]</span> <code>\snon solum\s(\w*?)\ssed etiam</code> will find all places where
            <span class="lat">non solum... sed etiam...</span> bracket just a single word.</li>
    </ul>
    <span class="emph">[*]</span>[Note: the automatic betacode feature will turn <code>\s</code> into <code>\ϲ</code>. so You can only execute
            this search on the Greek authors if you have some other corpus turned on too.]
    <br />
    <br />
    Unfortunately a lot of swanky heavy duty regex searches do not make sense: the DB is organized as a collection of 'lines'.
    A search like
    <code>\s\w\w\s\w\w\s\w\w\s\w\w\s</code> probably only makes sense in the context of verse authors. This is because
    <span class="emph">your regex cannot look outside of a single database line</span>. The sort of multi-line searching via
    regex that one might do in a flat text file will fail to find all occurrences of the expression.
    <br />
    <br />
    Consider again
    <code>\snon solum\s(\w*?)\ssed etiam</code>. If the <code>non solum</code> is not on the same line as the <code>sed etiam</code>, then
    you will not have a match. If your first search term includes a whitespace, then the search will move through
    Hipparchia as a "phrase" (where what matters most is the longest term). This will explore multi-line search zones.
    But you will lose a certain amount of speed and fine-grained control over the details as well.

    If you have to have the sort of search that has full access to lookaheads and what not, then you should consider migrating
    to <a href="https://community.dur.ac.uk/p.j.heslin/Software/Diogenes/index.php">Diogenes</a>.

    Hipparchia's internal data model will never be a good fit for that sort of thing. Even if various workarounds are possible,
    there is no reason to settle for the wrong tool for the job.


</div>

<div id="HitsAndMisses">

    Hipparchia stores three versions of every line: a formatted version (which includes information about font display, etc.),
    a version with accented words only, and a version of accentless words only.
    The actual searches are executed on the words only versions.

    <ul class="forexample">
        <li>formatted: <code>Μῆνιν ἄειδε θεὰ Πηληϊάδεω Ἀχιλῆοϲ</code></li>
        <li>accents only: <code>μῆνιν ἄειδε θεὰ πηληϊάδεω ἀχιλῆοϲ</code></li>
        <li>unaccented: <code>μηνιν αειδε θεα πηληιαδεω αχιληοϲ</code></li>
    </ul>

    <p><span class="label">Whitespace is your friend</span></p>

    A search for <code>"βαλλω"</code> is not the same as a search for <code>" βαλλω"</code>. If you want only
    things like βάλλων and not διαβάλλων or ἀμβαλλώμεθα or μεταβάλλωϲιν, then you should put a space in front
    of your search term:<code>" βαλλω"</code>. Similarly an exact match for βάλλω and only βάλλω requires you to put a whitespace on either
    side of your search term and to ask for <code>" βαλλω "</code>.

    <p><span class="label">Case sensitivity</span></p>

    It is important to note that <span class="emph">you cannot search for capital letters</span> vs lower-case letters.
    Accordingly in an accent-aware search ἀχαιούϲ will find Ἀχαιούϲ and ἀχιλῆοϲ will find Ἀχιλῆοϲ. It is less
    surprising that αχιληοϲ finds Ἀχιλῆοϲ in an unaccented search. But it is worth noting that all searches are themselves made
    lower case: ΑΧΙΛΗΟΣ will also find Ἀχιλῆοϲ.

    <p><span class="label">How to execute a phrase search combined with a proximity search</span></p>

    <span class="emph">You must put a word in the first box and a phrase in the second box</span>. You cannot search for two phrases.
    If you type a phrase into the first box and a single word into the second box, then Hipparchia will ignore the second box.
    But if you type a single word (or part of a word) into the first box and a phrase into the second box, Hipparchia
    will search for WordA near PhraseB. For example:
    <span class="sampleoutput">Sought αξιολογ within 2 lines of μεϲημβρια ετυγχαν; Searched 6625 texts and found 2 passages (<span class="colorhighlight">23.05s</span>)</span>
    <br />
    <br />
    Please note that you can also use regular expressions here. The previous search can be rewritten as follows:
    <span class="sampleoutput">Sought αξιολ.γ within 2 lines of μεϲ.μβρια ετ.γχαν; Searched 146595 texts and found 2 passages (<span class="colorhighlight">23.01s</span>)</span>

    <p><span class="label">Latin vs "accents matter"</span></p>

    You almost certainly want to avoid accented searches in the Latin authors unless you are willing to deal with the
    <code>v</code> vs <code>u</code> problem. Every v is a u in the unaccented data. And that means that the extremely
    inconsistent practice of various editors can be unified. Only do accented searches of texts whose editorial habits you
    understand. Then it will be safe to look for <code>íntro</code> and <code>hóc</code> specifically. Also keep your
    regex cheat sheet handy: either <code>(v|u)</code> or <code>[uv]</code> will ignore the difference between
    u and v.

    <p><span class="label">Automatic betacode</span></p>

    If you are searching the Greek authors and only Greek authors, then anything you type in Roman characters will be
    converted into betacode: <code>beta</code> becomes <code>βετα</code>, <code>udwr</code> becomes <code>υδωρ</code>
    and <code>u(/dwr</code> will be <code>ὕδωρ</code>. This means you can't search for the
    Latin inside of these texts unless you turn on some other corpus as well. Note that this bit of magic is not available
    for the other corpora because the texts inside them are bilingual. Enter unicode Greek into the search box instead.
    If you don't already have a unicode keyboard, consider looking into
    <a href="https://classicalstudies.org/publications-and-research/about-greekkeys-2015">GreekKeys</a>.

    <p><span class="label">Iota subscript and adscript</span></p>

    Hipparchia distinguishes between ἀ, ᾀ, ᾶ, ᾷ, ᾳ, and so forth in the searches wehre accents matter. But it has no way of
    figuring out the difference between a subscript and an adscript. If a text prints ᾶι instead of ᾷ, a search for ᾷ
    will not yield the results you wanted.
    <br />
    <br />
    If you say that accents do not matter, then all iota subscripts become meaningless: ᾷ is α. This also means that
    the Doric genitive singular and the Attic dative singular and the duals of many nouns will all match: τῶ and τῷ are now τω.
    But how often will this be a problem for you?
    <br />
    <br />
    If a text prints ᾶι instead of ᾷ, one has to search for αι to get a match if accents are turned off.
    Hands-on work with a text you really care about will let you quickly determine what, if any, efforts you should
    make to deal with this issue.
    <br />
    <br />
    People obsessed about accents will note that Θρᾷξ appears in the corpus as Θρᾷξ, Θρᾶξ, Θρᾲξ, and Θράξ. So maybe it is ok to turn
    accents off from time to time if you want to find everything that is out there. Check my work: search for
    <code>\sθρ[^ᾷίὶ]ξ\s</code>

    <p><span class="label">Lunate sigma</span></p>

    Internally <span class="emph">all sigmas are lunate</span> unless that sigma is part of some special case.
    You can type any sort of sigma you want,
    but there is no way to 'find' a σ vs an ς since your query will turn into ϲ. Note that this means that any ς that
    is present cannot be found. But were you really going to search for &#x03b6;&#x0337;&#x03c2;&#x0300;? Try to take
    comfort in the fact that a search just for &#x03b6;&#x0337; will turn up what you were after. A capital sigma for stater
    is a problem, though: you will see it (&#x03a3;), but, unlike almost all other special symbols, you can't search for it.

    <p><span class="label">"Search suspended: cap reached"</span></p>

    The list of items to search is not sorted. <span class="emph">Only results are sorted</span>. This means that
    if you want 200 hits in chronological order, you will get 200 hits in chronological order, but, unless you experience
    a bit of odd luck, you will not get
    the 200 earliest possible hits (because the full search did not take place). The way the search lists are built and
    dispatched means that some corpora will be searched before others and then with a higher chance of certain internal ID
    numbers being checked before others. Do not try to figure out the rules of the game, either raise the cap or refine
    your search instead.


</div>


<div id="SpeedSearching">
    <br />
    Search times will vary widely. If things seem unbearably slow, you should consider
    changing your queries and/or the restrictions placed upon them. <span class="emph">Everything hinges on what you ask for</span>.
    Slowdowns obey an exponential logic: things get 2x worse, then 4x worse, then...
    This means that little shifts in your search can lead to huge improvements.
    <br />
    <br />
    As noted below, hardware is a factor, but since you are unlikely to change your hardware much, let's start by spending some
    time looking at the software side of things. But if your searches are about <span class="emph">50-100x slower</span> than these examples, you should
    read about hardware.

    <ul class="forexample">
        <li>Consider the following <span class="emph">simple searches</span>. Both searches are across all five databases. There are no restrictions applied at all.
        <ul class="numbered">
            <li><span class="sampleoutput">Sought προκατέλαβον; Searched 236840 texts and found 22 passages (<span class="colorhighlight">4.19s</span>)</span></li>
            <li><span class="sampleoutput">Sought δεδιότεϲ; Searched 236840 texts and found 589 passages (<span class="colorhighlight">6.89s</span>)</span></li>
        </ul>
        The first search is quite fast: a long word and an uncommon word.
        The second search is really about the same speed: most of the extra time was spent on formatting the 589 results not on
        generating the hits themselves. <span class="emph">Unrestricted searches for individual words will always be fastest</span>.
        Common words will slow things down somewhat, but the slowdown is trivial relative to the amount of time it will take
        you to sift through 1000+ results.
    </li>
    <li>Now let's look at some searches just inside 'Inscriptions I'.
        <ul class="numbered">
            <li><span class="sampleoutput">Sought πολιτεια; Searched 139970 texts and found 992 passages (<span class="colorhighlight">13.63s</span>)</span></li>
            <li><span class="sampleoutput">Sought πολιτεια; Searched 112493 texts and found 895 passages (<span class="colorhighlight">11.34s</span>)</span></li>
            <li><span class="sampleoutput">Sought πολιτεια; Searched 57627 texts and found 631 passages (<span class="colorhighlight">22.61s</span>); Searched between 600 B.C.E. and 200 B.C.E.</span></li>
        </ul>

        There were no restrictions on the first search. The searching part took about one second. The formatting took the other 12s.<br  />
        The second search was restricted by 'Not Attica' for the author locations. The searching part took about one second. The formatting took most of the time.<br  />
        The third search was 'Not Attica' and <span class="emph">it also had a time restriction</span>. The search itself took a lot longer.
        <br />
        <br />
        Every 'author' is stored in a 'table'.  <span class="emph">Searching a whole table is much faster</span> than searching now one bit and now another bit.
        Delos (IG XI,4 [510-1349]) contains 841 works. 315 of them fall between 600 B.C.E. and 200 B.C.E. Once you restrict the time,
        the search of this 'author' turns into 315 mini searches. This is a lot slower than a single pass through that table.
        It is really when searching papyri and the inscriptions where you feel this: the Greek and Roman authors usually have
        fewer than 10 embedded works.
    </li>
    Obviously we will go a lot faster if we either add or subtract restrictions: the more a table is broken up into bits,
    the slower you will go. But more restrictions might mean you only needed to look at 10 items inside of the table: that's
    fast...
    </li>
    <li>
    Here are some searches just inside 'Greek Authors'.
        <ul class="numbered">
            <li><span class="sampleoutput">Sought κεκωλυκατε within 2 lines of ιδιωταϲ; Searched 6625 texts and found 1 passages (<span class="colorhighlight">0.97s</span>)</span></li>
            <li><span class="sampleoutput">Sought πραγμοϲυν within 2 lines of ιδιωταϲ; Searched 6625 texts and found 2 passages (<span class="colorhighlight">8.08s</span>)</span></li>
            <li><span class="sampleoutput">Sought καλοϲ within 5 words of αγαθοϲ; Searched 6625 texts and found 74 passages (<span class="colorhighlight">38.78s</span>)</span></li>
            <li><span class="sampleoutput">Sought καλοσ within 5 words of αγαθος; Searched 3008 texts and found 75 passages (<span class="colorhighlight">5.76s</span>); Searched between 850 B.C.E. and 1 C.E.</span></li>
        </ul>
    <span class="emph">A proximity search is really two searches</span>. Hipparchia looks for the <span class="emph">longest term first</span>.
    It is possible that the long term is more common than the short term, but if, like Hipparchia, you have to guess blindly, then you pick the
    longer term every time.
    After searching for the first term Hipparchia looks for places
    where the second term is near the first term. [NB: If you say a short term not near a long term, then the search will be for
    the short term and then the long term. That's what you really wanted.] This two-step process explains the results you see above.
    Let's walk through what happened when the search executed.
    <ul class="roman">
    <li>
        There are only
        two places where κεκωλύκατε appears. Finding them takes less than a second. Checking each location for ἰδιώταϲ takes
        less than a hundredth of a second.</li>
    <li>
        A search for πραγμοϲυν will turn up 585 passages. It does not take much time to find them. And it does not take
        all that much time to check those findings to see if they have ιδιωταϲ near them. A simple single-term search that generates 585 hits for
        πραγμοϲυν takes 5.58s seconds, but a lot of that is spent formatting the results. So the proximity penalty is for looking for
        πραγμοϲυν near ιδιωταϲ really quite low.
    </li>
    <li>
        καλοϲ within 5 words of αγαθοϲ is a different story. Hipparchia is first going to look for every αγαθοϲ in extant
        Greek literature. Then those passages will be checked for καλοϲ. The first pass generates a huge number of hits
        and so the second pass takes plenty of time to complete.
        But lest ye be scared off from your search for the good and the beautiful, note that adding a time restriction
        immediately speeds up the search considerably. Confidence in the ugliness of later Greek is all you need.
    </li>
    <li>
        In sum, <span class="emph">full corpus searches for two common words will be slow.</span> <a href="https://community.dur.ac.uk/p.j.heslin/Software/Diogenes/index.php">Diogenes</a>
        can do this sort of thing much faster if you decide that this sort of query is vital to your research. It would
        be possible to build a version of Hipparchia that is better at this kind of search, but that would mean
        building a method to generate pseudo-texts and then to search them with regex, i.e., to insert a little parody
        of Diogenes into Hipparchia.
        </ul>
    </li>
    <li>
    <span class="emph">Phrase searches are special cases of proximity searches</span>: A near B and in that order. Strategies and results will be
    very similiar to what we saw in the previous case.
        <ul class="numbered">
            <li><span class="sampleoutput">Sought ἀνὴρ καλόϲ τε καὶ ἀγαθὸϲ; Searched 6625 texts and found 3 passages (<span class="colorhighlight">29.27s</span>)</span></li>
            <li><span class="sampleoutput">Sought μεγάλην δύναμιν; Searched 6625 texts and found 84 passages (<span class="colorhighlight">42.78s</span>)</span></li>
            <li><span class="sampleoutput">Sought ἀνὴρ καλόϲ τε καὶ ἀγαθὸϲ; Searched 3008 texts and found 2 passages (<span class="colorhighlight">2.15s</span>); Searched between 850 B.C.E. and 1 C.E.</span></li>
            <li><span class="sampleoutput">Sought μεγάλην δύναμιν; Searched 3008 texts and found 32 passages (<span class="colorhighlight">4.25s</span>); Searched between 850 B.C.E. and 1 C.E.</span></li>
            <li><span class="sampleoutput">Sought ου μην αλλ; Searched 180 texts and found 110 passages (<span class="colorhighlight">2.06s</span>). Searched between 850 B.C.E. and 1 C.E. [+ Author categories limited to 'Oratores']</span></li>
        </ul>
    As above, a common word sought across the whole corpus will slow you down.
    Most phrase searches are likely to contain common words. So you will need strategies to make the haystack smaller
    unless you have 45s to spare. It is totally safe to try to double-check Dennison on οὐ μὴν ἀλλὰ, but you should
    throw some restrictions in there to avoid a long search (that yields more results than you want anyway).
    </li>
</ul>
    <span class="emph">Hardware also matters</span>: προκατέλαβον (the first example above)
    takes 4.19s with 5 workers on macOS 10.11 with a SSD and an 8 core CPU running at 3.5GHz.
    With one worker the search executes in 11.32s. The search takes 4.85 seconds on a mac mini with a SSD and 2 cores running at 2.6GHz. But then
    the search will take
    23.4s when executed inside a virtual machine running on the same higher-end computer,
    a virtual machine that has been assigned 4 cores and is running FreeBSD 11.
    The κεκωλυκατε example yields a difference between 0.97s unemulated and 12.79s when inside a virtual machine. In short, emulation is costly. And
    the main culprit is the emulated filesystem. Just see what happens if you pick ZFS instead of UFS...
    A single word inside of just "Greek authors" takes 154s on a low end machine with a very slow 5400rpm 2.5" laptop
    drive.
    The processor load remains very low throughout the search: the culprit is the cheap hard drive. The same word can be found in 2.16s on the speedier machine:
    Hipparchia is <span class="emph">50x-75x faster</span> with a faster drive.
    A solid state drive makes a huge difference here (and just about everywhere else in your computing life). Consider investing in one.
    In sum, fast drives and then more CPUs and then faster CPUs would be the order in which to seek to make speed gains.
    <span class="emph">Access time to the data and not processing time of the data is far and away the most important factor.</span>
    Get Hipparchia's DB onto a solid state drive if at all possible. But at a certain point a faster machine will end up just doing more waiting
    for data to come to the processor. 2 or 3 workers on a moderately powerful machine with a fast drive is 85% as fast as a high end machine that in theory
    can do 600% more work per second.

</div>

<div id="Oddities">
    The original data was not really designed to be aggregated. It was also not meant to be sliced up after this fashion.
    Various oddities and peculiarities ensue.

    <br />
    <p><span class="label">Missing in action</span></p>
    <ul class="forexample">
        <li>The Latin authors data is missing:
            <ul>
                <li>Dates</li>
                <li>Author Genres</li>
                <li>Author Locations</li>
                <li>Work Genres</li>
                <li>Work Locations</li>
            </ul>
        </li>
        <li>The Greek authors data is missing:
            <ul>
                <li>[nothing]</li>
            </ul>
        </li>
        <li>The papyrus data is missing:
            <ul>
                <li>Author Genres</li>
                <li>Author Locations</li>
                <li>Work Genres</li>
            </ul>
        </li>
        <li>The inscriptions data (I & II) is missing:
            <ul>
                <li>Author Genres</li>
            </ul>
        </li>
    </ul>

    <p><span class="label">Internal heterogeneity</span></p>
    <ul class="forexample">
            <li><span class="emph">Dates</span>
                <ul class="numbered">
                    <li>The dates recorded with the <span class="emph">Greek authors</span> are not of the same sort as those recorded with the papyri and inscriptions.
                        The Greek authors data is derived from LSJ and it originally looks like <code>A.D. 2–3?</code>. Some
                        items are listed as <code>Varia</code> or <code>Incerta</code>.

                            In short, these dates are approximate and inexact.
                            Everything gets converted to the center of any available century or range of centuries.
                            All questions are ignored.

                            <ul class="roman">
                                <li><code>4 BC ==> 350 BCE</code></li>
                                <li><code>A.D. 2–3? ==> 200 CE</code></li>
                            </ul>

                        The net result is that it is very easy to exclude authors by being over-refined in your search. <span class="emph">The margin of error is at least 50 years</span>.

                        </li>
                        <li>
                            The dates recorded with the <span class="emph">papyri</span> and the <span class="emph">inscriptions</span> vary from <code>?</code> to something very precise like <code>212 CE</code>. Hipparchia has
                            parsed the dates that the editors have assigned to these items as best as it can. Please note that there are
                            <span class="emph">21584</span> distinct <code>recorded_date</code> values in the works table. Some of these are in German, some use Roman numerals, some use 'a' and 'p',
                            some 'BC' and 'AD', some ordinal numbers, some cardinal numbers. Some merely say 'the age of X'. It's not easy to get all of these right
                            (even if the editorial date is itself accurate...). It is not even easy to check that they are right.
                            As above, all questions are dropped and all spans are turned into a single number representing the midpoint.
                            'Ages' have had dates assigned to them. Claudius will be the middle of the reign, approximately: 50 CE.
                            'Byzantine' is a bit trickier... 700 CE has been chosen for lack of some other solution.
                            Rough/round numbers have been chosen where something specific is not available. Many items are dated precisely,
                            many to within a decade, others are lucky to be assigned to the right century. Check the editor's date
                            (if available...) at the top of any inscription to see where the <code>assigned_date</code> came from.
                            <span class="emph">Avoid over-refined searches</span>
                            unless you know that you do not care about items that have not been dated with some precision.

                        </li>
                </ul>
            </li>
            <li><span class="emph">Author Locations</span>
                <ul class="numbered">
                    <li>
                        The locations recorded with the <span class="emph">Greek authors</span> are not of the same sort as those recorded with the papyri and inscriptions.
                        The Greek authors data is derived from LSJ and it originally looks like <code>Athenae</code>,
                        <code>Ilium [vel Troja]</code>, and <code>Sinope</code>. <span class="emph">Many authors have no location
                        recorded</span>. Be careful not to throw out more authors than you mean to by putting too much confidence in this data.
                    </li>
                    <li>
                        The locations for <span class="emph">inscription</span> 'authors' is inferential. If the name of the corpus contains something that
                        looks like a location, it has been grabbed: <code>Attica</code> for example. Note that <code>Attica</code> is not <code>Athenae</code>: you would need
                        to ask for both locations to get IG's Attica + LSJ's Attic authors. Some sets of inscriptions come from more than one
                        place: <code>Cos and Calymna</code>, for example, and not just <code>Cos</code>.
                        Furthermore many corpora do not have any (pseudo-)locations that can be inferred from their name: for example,
                        <code>Late Antique Latin</code> is not a place, at least not a literal one.
                    </li>
                </ul>
            </li>
            <li><span class="emph">Work Locations</span>
              <ul class="numbered">
        <li>
            There are 14001 distinct locations on offer. That's a painfully large number. It is not at all easy to
            pare these down in an automated fashion. 110 start with 'Alex'. Some of these could be folded into one
            another, but the data has many shapes, and no decision has been made yet about where/how to make the unkind cuts.
        </li>
        <li>
            Some items have both a region and a city recorded. Only the city is searchable for now. The uneven distribution
            of regional assignments means that searching by region would be misleading.
        </li>
    </ul>
            </li>
            <li><span class="emph">Missing characters and display quirks</span>
                <ul class="numbered">
                    <li>
                        There are various unprintable characters in the original data. These fall under various headings
                    </li>
                        <ul class="roman">
                            <li>
                                Idiosyncratic characters that have no unicode representation. You will see <span class="emph">◦</span> in the text. If you look at
                                the database and/or HTML output you will see a code number:
                                <code>hmu_idiosyncratic_char value="1122"</code>, e.g.
                                This can be decoded via the Betacode manual.
                                It is possible to know what was in the text, but it is not possible to display it, at least not yet.
                            </li>
                            <li>
                                Undocumented characters are all rendered as <span class="emph">⊚</span>. If you look at
                                the database and/or HTML output you will see a code number:
                                <code>hmu_undocumented_poundsign value="1069"</code>, e.g.
                                The original data has either been misparsed or it yielded a value that is not present in the Betacode manual.
                                Further documentation ought to make it possible to put the proper character in here.
                            </li>
                            <li>
                                Some characters will not display becuase they have been properly encoded but they are missing from your fonts.
                                They will display properly if/when you get a font that supports them.
                            </li>
                            <li>
                                Finally, some characters will not display because the betacode manual does give a code that could
                                be turned into a character but that code has yet to be implemented in HipparchiaBuilder. The betacode
                                manual is 99 pages long, so this is not just a case of laziness.
                            </li>
                        </ul>
                    <li>
                        Formatting instructions have typically been followed: make the font bigger, superscript, cross out... But not
                        all of the codes found have been documented. And some are too painful to implement: start multi-column display,
                        reverse text direction, writing perpendicular to main text, ... Probing the database will usually let you know what was found.
                        But it most of these items are unlikely to ever be supported.
                    </li>
                    <li>
                        Brackets that converge with HTML or other markup have typically been replaced with a near equivalent: <code>&lt;</code>
                        signals markup instructions to a page renderer. Left and right angled bracket were swapped out.
                        They are present in the database with other characters instead: <span class="emph">⟪</span> and <span class="emph">⟫</span>.
                        A similar logic governed the choice of <span class="emph">⦅</span> and <span class="emph">⦆</span>
                        since <code>(</code> and <code>)</code> are special characters in betacode.
                        There are other (hopefully) inconsequential items that fall under this heading.
                    </li>

                </ul>
            </li>
            <li><span class="emph">Dictionary entries: click to define, etc.</span>
                <ul class="numbered">
                    <li>
                        The dictionary data is being asked to do more than it was orignally designed to do. The "senses" and "phrases"
                        that have been extracted are interpretations of the data. Any irregularities (and there are many...) will
                        produce surprises. Read the full entry rather than the summary if there is any confusion.
                    </li>
                    <li>
                        Clicking on any word in a browser passage is supposed to parse it and open a dictionary window that defines
                        that word. This often works, but not always. The parser has to know the word. And then the dictionary entry
                        has to match the parser's idea of what the dictionary entry should be. The hand-off between various sets of data
                        is not always smooth. You can always look up any word manually by opening up the lexical tools panel:
                            <button class="ui-button ui-corner-all ui-widget ui-button-icon-only" title="Lexical tools">
                            <span class="ui-icon ui-icon-wrench"></span>
                            <span class="ui-button-icon-space"> </span>&nbsp;</button>
                    </li>
                    <li>
                        Citations within the dictionaries are <span class="emph">often clickable</span>. The emphasis falls on the word often.
                        If you click on <code>D.10.74</code> you will be taken to Demosthenes, Philippica 4 [Sp.], Section 74, line 1.
                        But there will be sorrow as well as joy. The citation format in the dictionary references does not match
                        the data that Hipparchia is working from and interconversion will often fail. For example, Plautus is cited by
                        "act" and "scene" in the dictionary entries. <code>Plaut. Merc. 1, 2, 76</code> is meaningless to Hipparchia since "Play"
                        and "line" are the only valid ways of retrieving anything. The number assigned to each of Euripides' plays in the
                        dictionary is not the same as in that data as is the number assigned in the TLG-E data. Papyri that are
                        available are cited, but so seldom in a useful manner that I did not code anything to try to retrieve them.
                        Nevertheless most of the key texts of key authors will pop right up. Cross your fingers, then click.
                    </li>
                </ul>

            </li>
            </ul>

</div>

<div id="Openness">
    <br />
    Hipparchia is open source software. This project would not have been possible had not a whole array of different individuals
    and teams elected to generously donate their time and energy to the furtherance of human knowledge.
    <br />
    <br />
    At every turn one will note the enabling power of the open source community, a community responsible for <a href="https://www.python.org">Python</a>
    and <a href="https://www.postgresql.org">PostgreSQL</a> as well as <a href="http://flask.pocoo.org">Flask</a>
    and <a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>.
    I could never have parsed the original data if the source code to <a href="https://community.dur.ac.uk/p.j.heslin/Software/Diogenes/index.php">Diogenes</a>
    had not been released under an open license. The browser you run to read this page (or any other) is almost certainly crammed to the gills with open source code.
    And <a href="https://html.spec.whatwg.org/multipage/">HTML</a> itself
    is an open standard maintained by bodies committed to openness.
    <br />
    <br />
    It can be easy to forget that "the market" as such in the digital age is enabled by and wholly dependent upon a host
    of generous and free gifts of ideas, methods, and implementations. Those who gave did not impose restrictions or limitations upon others.
    They did not prevent people from doing with these gifts what they chose to do with them. The fruits of these gifts have transformed
    the world.
    <br />
    <br />
    Of course we classicists knew all along that κτήματα ἐϲ αἰεί will win out over ἀγωνίϲματα πρὸϲ τὸ παραχρῆμα λυϲιτελοῦν.
    <br />
    <br />

   </div>

</div>
